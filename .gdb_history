stepi
print $ebx
stepi
print $eax
print *(int*)($eax)
break codegen_generate_entity_access_array_bracket_pointer
run
break codegen_generate_entity_access_array_bracket
run
next
step
next
next
print *result->last_entity 
break resolver.c:396
run
break resolver.c:396
run
print *custom_dtype 
print *node
break main
run
layout asm
stepi
print $eax
print $edx
stepi
break codegen.c:2151
run
break codegen.c:2151
run
print *result
print *result->last_entity 
break validate_node
run
next
print *node
c
next
print *node
run
run
bt
break symresolver_end_table
run
break symresolver_end_table
run
next
print last_table
print vector_peek(compiler->symbols.tables)
break symresolver.c:38
run
print last_table
print *last_table
break symresolver_new_table
run
next
print compiler->symbols.table
print compiler->symbols
c
next
print compiler->symbols.table
print &compiler->symbols.table
print *compiler->symbols.table
step
next
c
break symresolver_end_table
run
c
break symresolver_end_table 
run
next
bt
next
print *last_table
print last_table
print vector_peek(compiler->symbols.tables)
print vector_peek(compiler->symbols.tables)
print vector_peek(compiler->symbols.tables)
print vector_peek(compiler->symbols.tables)
print vector_peek(compiler->symbols.tables)
break symresolver.c:Â£6
run
break symresolver.c:36
run
print vector_peek(compiler->symbols.tables)
break symresolver.c:36
run
next
print last_table
print *last_table
break symresolver.c:23
run
c
print compiler->symbols.table
break symresolver_end_table
c
next
next
print last_table
print *(void*)(0x55555558c500)
print *(int*)(0x55555558c500)
print (int*)(0x55555558c500)
print (struct symbol*)(0x55555558c500)
print *(struct symbol*)(0x55555558c500)
print *(struct vector*)(0x55555558c500)
print *(struct vector*)(0x55555558c500)
break symresolver.c:37
run
print *last_table
next
break symresolver_new_table
run
next
c
next
print compiler->symbols.table
break symresolver_end_table
c
next
print last_table
next
print *compiler->symbols.table
c
break validate_return_node
run
next
print node->func.rtype
break validator.c:89
run
print node->func.rtype
next
print node->func.rtype
print *node
break parse_keyword_return
run
next
break codegen_generate_statement_return_exp
run
next
break codegen.c:2143
run
break codegen.c:2139
run
break     // If the last entity is not a pointer then it must be accessed as a value.
clear
break codegen_resolve_node_for_value
run
break resolver_fllow
break resolver_follow
run
bt
c
bt
break codegen_gen_mem_access
run
next
c
next
break codegen_gen_mem_access
run
next
break codegen.c:1272
run
next
run
bt
layout asm
stepi
layout asm
break main
run
stepi
print $eax
break main
run
layout asm
stepi
print $eax
print $edx
break main
run
layout asm
stepi
print $edx
break codegen.c:1811
run
next
break codegen.c:1821
run
break parser.c:2251
run
break parser.c:254
run
print stack_addition
next
print offset
print *last_entity
print *last_entity->node
bt
run
break parser.c:250
run
print *last_entity
print *last_entity->node
break parser.c:250
run
bt
c
break parse_function
run
next
print *parser_scope_last_entity_local_scope
print *parser_scope_last_entity_local_scope()
print *parser_scope_last_entity_local_scope
print parser_scope_last_entity_local_scope()
break parse_function
run
next
print *parser_scope_last_entity_local_scope 
print parser_scope_last_entity_local_scope 
print parser_scope_last_entity_local_scope 
print parser_scope_last_entity_local_scope()
break parser_scope_last_entity_local_scope
print parser_scope_last_entity_local_scope()
break parser.c:2247
run
next
step
next
step
next
oh...  that explaoins it.
break scope_last_entity_from_scope_stop_at
run
next
print stop_scope
print scope
break parser.c:2635
run
next
print process->scope
break parser.c:246
run
print *current_process->scope
print current_process->scope
print current_process->scope->root
step
next
print stop_scope
step
next
print stop_scope
print scope
next
